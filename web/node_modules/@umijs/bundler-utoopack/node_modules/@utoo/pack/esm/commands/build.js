import { handleIssues } from "@utoo/pack-shared";
import { spawn } from "child_process";
import fs from "fs";
import { nanoid } from "nanoid";
import path from "path";
import { resolveBundleOptions } from "../config/webpackCompat";
import { projectFactory } from "../core/project";
import { HtmlPlugin } from "../plugins/HtmlPlugin";
import { blockStdout, createDefineEnv, getPackPath } from "../utils/common";
import { findRootDir } from "../utils/findRoot";
import { getInitialAssetsFromStats } from "../utils/getInitialAssets";
import { processHtmlEntry } from "../utils/htmlEntry";
import { validateEntryPaths } from "../utils/validateEntry";
import { xcodeProfilingReady } from "../utils/xcodeProfile";
export function build(options, projectPath, rootPath) {
    const bundleOptions = resolveBundleOptions(options, projectPath, rootPath);
    if (!rootPath) {
        // help user to find the rootDir automatically.
        rootPath = findRootDir(projectPath || process.cwd());
    }
    return buildInternal(bundleOptions, projectPath, rootPath);
}
async function buildInternal(bundleOptions, projectPath, rootPath) {
    var _a, _b, _c, _d, _e, _f;
    blockStdout();
    if (process.env.XCODE_PROFILE) {
        await xcodeProfilingReady();
    }
    const resolvedProjectPath = projectPath || process.cwd();
    processHtmlEntry(bundleOptions.config, resolvedProjectPath);
    validateEntryPaths(bundleOptions.config, resolvedProjectPath);
    const createProject = projectFactory();
    const project = await createProject({
        processEnv: (_a = bundleOptions.processEnv) !== null && _a !== void 0 ? _a : {},
        defineEnv: createDefineEnv({
            config: bundleOptions.config,
            dev: (_b = bundleOptions.dev) !== null && _b !== void 0 ? _b : false,
            optionDefineEnv: bundleOptions.defineEnv,
        }),
        watch: {
            enable: false,
        },
        dev: (_c = bundleOptions.dev) !== null && _c !== void 0 ? _c : false,
        buildId: bundleOptions.buildId || nanoid(),
        config: {
            ...bundleOptions.config,
            stats: Boolean(process.env.ANALYZE) ||
                bundleOptions.config.stats ||
                bundleOptions.config.entry.some((e) => !!e.html),
        },
        projectPath: projectPath || process.cwd(),
        rootPath: rootPath || projectPath || process.cwd(),
        packPath: getPackPath(),
    }, {
        persistentCaching: false,
    });
    const entrypoints = await project.writeAllEntrypointsToDisk();
    handleIssues(entrypoints.issues);
    const htmlConfigs = [
        ...(Array.isArray(bundleOptions.config.html)
            ? bundleOptions.config.html
            : bundleOptions.config.html
                ? [bundleOptions.config.html]
                : []),
        ...bundleOptions.config.entry
            .filter((e) => !!e.html)
            .map((e) => e.html),
    ];
    if (htmlConfigs.length > 0) {
        const assets = { js: [], css: [] };
        const outputDir = ((_d = bundleOptions.config.output) === null || _d === void 0 ? void 0 : _d.path) || path.join(process.cwd(), "dist");
        if (assets.js.length === 0 && assets.css.length === 0) {
            const discovered = getInitialAssetsFromStats(outputDir);
            assets.js.push(...discovered.js);
            assets.css.push(...discovered.css);
        }
        const publicPath = (_e = bundleOptions.config.output) === null || _e === void 0 ? void 0 : _e.publicPath;
        for (const config of htmlConfigs) {
            const plugin = new HtmlPlugin(config);
            await plugin.generate(outputDir, assets, publicPath);
        }
    }
    if (process.env.ANALYZE) {
        await analyzeBundle(((_f = bundleOptions.config.output) === null || _f === void 0 ? void 0 : _f.path) || "dist");
    }
    await project.shutdown();
    // TODO: Maybe run tasks in worker is a better way, see
    // https://github.com/vercel/next.js/blob/512d8283054407ab92b2583ecce3b253c3be7b85/packages/next/src/lib/worker.ts
}
async function analyzeBundle(outputPath) {
    const statsPath = path.join(outputPath, "stats.json");
    if (!fs.existsSync(statsPath)) {
        console.warn(`Stats file not found at ${statsPath}. Make sure to enable stats in your configuration.`);
        return;
    }
    return new Promise((resolve, reject) => {
        const analyzer = spawn("npx", ["webpack-bundle-analyzer", statsPath], {
            stdio: "inherit",
            shell: true,
        });
        analyzer.on("error", (error) => {
            reject(new Error(`Failed to start bundle analyzer: ${error.message}`));
        });
        analyzer.on("close", () => {
            // The analyzer process has finished, so we can resolve the promise
            // to allow the build process to exit gracefully.
            resolve();
        });
    });
}
