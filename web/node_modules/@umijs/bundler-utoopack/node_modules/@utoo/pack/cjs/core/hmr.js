"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FAST_REFRESH_RUNTIME_RELOAD = exports.HMR_ACTIONS_SENT_TO_BROWSER = void 0;
exports.createHotReloader = createHotReloader;
const pack_shared_1 = require("@utoo/pack-shared");
const nanoid_1 = require("nanoid");
const path_1 = __importDefault(require("path"));
const ws_1 = __importDefault(require("ws"));
const HtmlPlugin_1 = require("../plugins/HtmlPlugin");
const common_1 = require("../utils/common");
const getInitialAssets_1 = require("../utils/getInitialAssets");
const htmlEntry_1 = require("../utils/htmlEntry");
const validateEntry_1 = require("../utils/validateEntry");
const project_1 = require("./project");
const wsServer = new ws_1.default.Server({ noServer: true });
const sessionId = Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
// Re-export HMR types from pack-shared for backward compatibility
var pack_shared_2 = require("@utoo/pack-shared");
Object.defineProperty(exports, "HMR_ACTIONS_SENT_TO_BROWSER", { enumerable: true, get: function () { return pack_shared_2.HMR_ACTIONS_SENT_TO_BROWSER; } });
exports.FAST_REFRESH_RUNTIME_RELOAD = "Fast Refresh had to perform a full reload due to a runtime error.";
async function createHotReloader(bundleOptions, projectPath, rootPath) {
    var _a;
    const resolvedProjectPath = projectPath || process.cwd();
    (0, htmlEntry_1.processHtmlEntry)(bundleOptions.config, resolvedProjectPath);
    (0, validateEntry_1.validateEntryPaths)(bundleOptions.config, resolvedProjectPath);
    const createProject = (0, project_1.projectFactory)();
    const project = await createProject({
        processEnv: (_a = bundleOptions.processEnv) !== null && _a !== void 0 ? _a : {},
        defineEnv: (0, common_1.createDefineEnv)({
            config: bundleOptions.config,
            dev: true,
            optionDefineEnv: bundleOptions.defineEnv,
        }),
        watch: {
            enable: true,
        },
        dev: true,
        buildId: bundleOptions.buildId || (0, nanoid_1.nanoid)(),
        config: {
            ...bundleOptions.config,
            mode: "development",
            stats: Boolean(process.env.ANALYZE) ||
                bundleOptions.config.stats ||
                bundleOptions.config.entry.some((e) => !!e.html),
            optimization: {
                ...bundleOptions.config.optimization,
                minify: false,
                moduleIds: "named",
            },
        },
        projectPath: projectPath || process.cwd(),
        rootPath: rootPath || projectPath || process.cwd(),
        packPath: (0, common_1.getPackPath)(),
    }, {
        persistentCaching: true,
    });
    const entrypointsSubscription = project.entrypointsSubscribe();
    let currentEntriesHandlingResolve;
    let currentEntriesHandling = new Promise((resolve) => (currentEntriesHandlingResolve = resolve));
    let hmrEventHappened = false;
    let hmrHash = 0;
    const clients = new Set();
    const clientStates = new WeakMap();
    function sendToClient(client, payload) {
        client.send(JSON.stringify(payload));
    }
    function sendEnqueuedMessages() {
        for (const client of clients) {
            const state = clientStates.get(client);
            if (!state) {
                continue;
            }
            for (const payload of state.hmrPayloads.values()) {
                sendToClient(client, payload);
            }
            state.hmrPayloads.clear();
            if (state.turbopackUpdates.length > 0) {
                sendToClient(client, {
                    action: pack_shared_1.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,
                    data: state.turbopackUpdates,
                });
                state.turbopackUpdates.length = 0;
            }
        }
    }
    const sendEnqueuedMessagesDebounce = (0, common_1.debounce)(sendEnqueuedMessages, 2);
    function sendTurbopackMessage(payload) {
        var _a;
        payload.diagnostics = [];
        payload.issues = [];
        for (const client of clients) {
            (_a = clientStates.get(client)) === null || _a === void 0 ? void 0 : _a.turbopackUpdates.push(payload);
        }
        hmrEventHappened = true;
        sendEnqueuedMessagesDebounce();
    }
    async function subscribeToHmrEvents(client, id) {
        const state = clientStates.get(client);
        if (!state || state.subscriptions.has(id)) {
            return;
        }
        const subscription = project.hmrEvents(id);
        state.subscriptions.set(id, subscription);
        // The subscription will always emit once, which is the initial
        // computation. This is not a change, so swallow it.
        try {
            await subscription.next();
            for await (const data of subscription) {
                (0, common_1.processIssues)(data, true, true);
                if (data.type !== "issues") {
                    sendTurbopackMessage(data);
                }
            }
        }
        catch (e) {
            // The client might be using an HMR session from a previous server, tell them
            // to fully reload the page to resolve the issue. We can't use
            // `hotReloader.send` since that would force every connected client to
            // reload, only this client is out of date.
            const reloadAction = {
                action: pack_shared_1.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD,
                data: `error in HMR event subscription for ${id}: ${e}`,
            };
            sendToClient(client, reloadAction);
            client.close();
            return;
        }
    }
    function unsubscribeFromHmrEvents(client, id) {
        const state = clientStates.get(client);
        if (!state) {
            return;
        }
        const subscription = state.subscriptions.get(id);
        subscription === null || subscription === void 0 ? void 0 : subscription.return();
    }
    async function handleEntrypointsSubscription() {
        var _a, _b;
        for await (const entrypoints of entrypointsSubscription) {
            if (!currentEntriesHandlingResolve) {
                currentEntriesHandling = new Promise(
                // eslint-disable-next-line no-loop-func
                (resolve) => (currentEntriesHandlingResolve = resolve));
            }
            const assets = { js: [], css: [] };
            await Promise.all(entrypoints.apps.map((l) => l.writeToDisk().then((res) => {
                (0, common_1.processIssues)(res, true, true);
            })));
            const htmlConfigs = [
                ...(Array.isArray(bundleOptions.config.html)
                    ? bundleOptions.config.html
                    : bundleOptions.config.html
                        ? [bundleOptions.config.html]
                        : []),
                ...bundleOptions.config.entry
                    .filter((e) => !!e.html)
                    .map((e) => e.html),
            ];
            if (htmlConfigs.length > 0) {
                const outputDir = ((_a = bundleOptions.config.output) === null || _a === void 0 ? void 0 : _a.path) || path_1.default.join(process.cwd(), "dist");
                const publicPath = (_b = bundleOptions.config.output) === null || _b === void 0 ? void 0 : _b.publicPath;
                if (assets.js.length === 0 && assets.css.length === 0) {
                    const discovered = (0, getInitialAssets_1.getInitialAssetsFromStats)(outputDir);
                    assets.js.push(...discovered.js);
                    assets.css.push(...discovered.css);
                }
                for (const config of htmlConfigs) {
                    const plugin = new HtmlPlugin_1.HtmlPlugin(config);
                    await plugin.generate(outputDir, assets, publicPath);
                }
            }
            currentEntriesHandlingResolve();
            currentEntriesHandlingResolve = undefined;
        }
    }
    const hotReloader = {
        turbopackProject: project,
        serverStats: null,
        onHMR(req, socket, head, onUpgrade) {
            wsServer.handleUpgrade(req, socket, head, (client) => {
                onUpgrade === null || onUpgrade === void 0 ? void 0 : onUpgrade(client);
                const subscriptions = new Map();
                clients.add(client);
                clientStates.set(client, {
                    hmrPayloads: new Map(),
                    turbopackUpdates: [],
                    subscriptions,
                });
                client.on("close", () => {
                    var _a;
                    // Remove active subscriptions
                    for (const subscription of subscriptions.values()) {
                        (_a = subscription.return) === null || _a === void 0 ? void 0 : _a.call(subscription);
                    }
                    clientStates.delete(client);
                    clients.delete(client);
                });
                client.addEventListener("message", ({ data }) => {
                    const parsedData = JSON.parse(typeof data !== "string" ? data.toString() : data);
                    // messages
                    switch (parsedData.event) {
                        case "client-error": // { errorCount, clientId }
                        case "client-warning": // { warningCount, clientId }
                        case "client-success": // { clientId }
                        case "client-full-reload": // { stackTrace, hadRuntimeError }
                            const { hadRuntimeError, dependencyChain } = parsedData;
                            if (hadRuntimeError) {
                                console.warn(exports.FAST_REFRESH_RUNTIME_RELOAD);
                            }
                            if (Array.isArray(dependencyChain) &&
                                typeof dependencyChain[0] === "string") {
                                const cleanedModulePath = dependencyChain[0]
                                    .replace(/^\[project\]/, ".")
                                    .replace(/ \[.*\] \(.*\)$/, "");
                                console.warn(`Fast Refresh had to perform a full reload when ${cleanedModulePath} changed.`);
                            }
                            break;
                        default:
                            // Might be a Turbopack message...
                            if (!parsedData.type) {
                                throw new Error(`unrecognized HMR message "${data}"`);
                            }
                    }
                    // Turbopack messages
                    switch (parsedData.type) {
                        case "turbopack-subscribe":
                            subscribeToHmrEvents(client, parsedData.path);
                            break;
                        case "turbopack-unsubscribe":
                            unsubscribeFromHmrEvents(client, parsedData.path);
                            break;
                        default:
                            if (!parsedData.event) {
                                throw new Error(`unrecognized Turbopack HMR message "${data}"`);
                            }
                    }
                });
                const turbopackConnected = {
                    action: pack_shared_1.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,
                    data: { sessionId },
                };
                sendToClient(client, turbopackConnected);
                const errors = [];
                (async function () {
                    const sync = {
                        action: pack_shared_1.HMR_ACTIONS_SENT_TO_BROWSER.SYNC,
                        errors,
                        warnings: [],
                        hash: "",
                    };
                    sendToClient(client, sync);
                })();
            });
        },
        send(action) {
            const payload = JSON.stringify(action);
            for (const client of clients) {
                client.send(payload);
            }
        },
        setHmrServerError(_error) {
            // Not implemented yet.
        },
        clearHmrServerError() {
            // Not implemented yet.
        },
        async start() { },
        async buildFallbackError() {
            // Not implemented yet.
        },
        close() {
            for (const wsClient of clients) {
                // it's okay to not cleanly close these websocket connections, this is dev
                wsClient.terminate();
            }
            clients.clear();
        },
    };
    handleEntrypointsSubscription().catch((err) => {
        console.error(err);
        process.exit(1);
    });
    // Write empty manifests
    await currentEntriesHandling;
    async function handleProjectUpdates() {
        for await (const updateMessage of project.updateInfoSubscribe(30)) {
            switch (updateMessage.updateType) {
                case "start": {
                    hotReloader.send({ action: pack_shared_1.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING });
                    break;
                }
                case "end": {
                    sendEnqueuedMessages();
                    const errors = new Map();
                    for (const client of clients) {
                        const state = clientStates.get(client);
                        if (!state) {
                            continue;
                        }
                        const clientErrors = new Map(errors);
                        sendToClient(client, {
                            action: pack_shared_1.HMR_ACTIONS_SENT_TO_BROWSER.BUILT,
                            hash: String(++hmrHash),
                            errors: [...clientErrors.values()],
                            warnings: [],
                        });
                    }
                    if (hmrEventHappened) {
                        const time = updateMessage.value.duration;
                        const timeMessage = time > 2000 ? `${Math.round(time / 100) / 10}s` : `${time}ms`;
                        console.log(`Compiled in ${timeMessage}`);
                        hmrEventHappened = false;
                    }
                    break;
                }
                default:
            }
        }
    }
    handleProjectUpdates().catch((err) => {
        console.error(err);
        process.exit(1);
    });
    return hotReloader;
}
